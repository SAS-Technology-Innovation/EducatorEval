import{a as b,c as s,d as a,g as p,b as u,e as i,q as d,o as h,l as w,s as E,w as l,u as v}from"./config.DNoymYbc.js";const m={async create(e){try{return(await b(s(a,"observations"),{...e,createdAt:new Date().toISOString(),updatedAt:new Date().toISOString()})).id}catch(r){throw console.error("Error creating observation:",r),new Error("Failed to create observation")}},async update(e,r){try{await v(u(a,"observations",e),{...r,updatedAt:new Date().toISOString()})}catch(t){throw console.error("Error updating observation:",t),new Error("Failed to update observation")}},async getByObserver(e,r=50){try{return(await i(d(s(a,"observations"),l("observerId","==",e),h("date","desc"),w(r)))).docs.map(o=>({id:o.id,...o.data()}))}catch(t){throw console.error("Error fetching observations by observer:",t),new Error("Failed to fetch observations")}},async getByTeacher(e,r=50){try{return(await i(d(s(a,"observations"),l("teacherId","==",e),h("date","desc"),w(r)))).docs.map(o=>({id:o.id,...o.data()}))}catch(t){throw console.error("Error fetching observations by teacher:",t),new Error("Failed to fetch observations")}},async getRecent(e=20,r){try{let t=d(s(a,"observations"),h("date","desc"),w(e));r&&(t=d(t,E(r)));const o=await i(t);return{observations:o.docs.map(n=>({id:n.id,...n.data()})),lastDocument:o.docs[o.docs.length-1]||null}}catch(t){throw console.error("Error fetching recent observations:",t),new Error("Failed to fetch recent observations")}},async getStats(){try{const r=(await i(s(a,"observations"))).docs.map(c=>c.data()),t=new Date;t.setDate(1),t.setHours(0,0,0,0);const o=r.filter(c=>new Date(c.date)>=t),n=r.filter(c=>c.crpEvidenceCount!==void 0),y=n.length>0?n.reduce((c,g)=>c+(g.crpEvidenceCount||0),0)/n.length:0;return{total:r.length,thisMonth:o.length,crpEvidenceAverage:Math.round(y)}}catch(e){throw console.error("Error getting observation stats:",e),new Error("Failed to get observation statistics")}}},S={async getAll(){try{return(await i(d(s(a,"teachers"),h("name")))).docs.map(r=>({id:r.id,...r.data()}))}catch(e){throw console.error("Error fetching teachers:",e),new Error("Failed to fetch teachers")}},async getById(e){try{const r=await p(u(a,"teachers",e));return r.exists()?{id:r.id,...r.data()}:null}catch(r){throw console.error("Error fetching teacher:",r),new Error("Failed to fetch teacher")}},async create(e){try{return(await b(s(a,"teachers"),e)).id}catch(r){throw console.error("Error creating teacher:",r),new Error("Failed to create teacher")}},async search(e){try{if(!e.trim())return await this.getAll();const r=await this.getAll(),t=e.toLowerCase();return r.filter(o=>o.name.toLowerCase().includes(t)||o.department?.toLowerCase().includes(t)||o.subjects?.some(n=>n.toLowerCase().includes(t)))}catch(r){throw console.error("Error searching teachers:",r),new Error("Failed to search teachers")}}},F={async getAll(){try{return(await i(d(s(a,"observations"),l("status","==","scheduled"),h("date"),h("startTime")))).docs.map(r=>({id:r.id,...r.data()}))}catch(e){throw console.error("Error fetching scheduled observations:",e),new Error("Failed to fetch scheduled observations")}},async getByDate(e){try{return(await i(d(s(a,"observations"),l("status","==","scheduled"),l("date","==",e),h("startTime")))).docs.map(t=>({id:t.id,...t.data()}))}catch(r){throw console.error("Error fetching observations by date:",r),new Error("Failed to fetch observations by date")}},async create(e){try{return(await b(s(a,"observations"),{...e,status:"scheduled",responses:{},comments:{},overallComment:"",duration:0})).id}catch(r){throw console.error("Error creating scheduled observation:",r),new Error("Failed to create scheduled observation")}},async cancel(e){try{await v(u(a,"observations",e),{status:"cancelled"})}catch(r){throw console.error("Error cancelling observation:",r),new Error("Failed to cancel observation")}},async update(e,r){try{await v(u(a,"observations",e),r)}catch(t){throw console.error("Error updating scheduled observation:",t),new Error("Failed to update scheduled observation")}}};export{m as o,F as s,S as t};
